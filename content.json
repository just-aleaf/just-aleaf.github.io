{"meta":{"title":"leaf","subtitle":"","description":"","author":"叶子","url":"http://just-aleaf.github.io","root":"/"},"pages":[{"title":"有感","date":"2022-08-01T17:07:58.000Z","updated":"2022-08-10T11:28:55.651Z","comments":true,"path":"Feeling/index.html","permalink":"http://just-aleaf.github.io/Feeling/index.html","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970心有山水不造作，静而不争远是非，内心丰盈即人生巅峰心想事成的秘诀,就是只想能成的的事一声炎帝，满是故事没有人会踏雾而来，喜欢的风景要自己努力去看脚下生风过剑急，白云出岫看梅西。雄鹰射落蓝天傲，百炼成钢命不移鬓微霜又何妨，三十四载仍称王等海贼王完结的那一天，我们第一集弹幕见吧关于顶上，皆是遗憾原来这世界上没有任何东西能胜过利益(8月5日)自此红蓝无梅西去年的今天，国王为城堡能留下的只有泪水当枷锁落地的那一刻我们都以为赢了艾草纷飞，斯人未归只要想起一生中后悔的事，梅花便落满了南山操纵比赛就是犯罪(风华正盛正想拿成绩的年纪，却被逼迫拱手送出冠军)那家伙要是很幸福，会挂着海贼旗一个人出海吗永远是那个不服输的少年Inmessionante太阳也不是天天出现的，但它一直都在分享欲是靠回应来延续的，热情也是花自向阳开，人终朝前走咽的下委屈才能撑的起格局你以为这就是结局，其实也可以是新的开始累了想父母，倦了想前程(回家的路上睡着了,梦里全是妈妈烧的菜)光而不耀，与光同尘永远不要基于短暂的情绪而做出永久性的决定人从悲伤中落落大方走出来就是艺术家河流从不催促过河的人那就出你下次哭，是因为太幸福你仅是你，万人非你草木生欢喜，山水解忧愁疲时知休，郁时知通，燥时知止先讲对方想听的，在讲对方听得进的，然后讲你该讲的，最后讲你想讲的20岁的我还没有爱情，无妨你还有80年的时光去追求爱情糖水爷爷:红豆汤,绿豆汤,银耳汤,米酒，给两块钱随便喝人性最大的恶:恨你有，笑有你，嫌你穷，怕你富一直以为蓝白间条纹象征着忧郁与遗憾，其实它是历经千帆后的风轻云淡"},{"title":"友情链接","date":"2022-08-02T12:11:48.130Z","updated":"2022-08-02T12:11:48.130Z","comments":true,"path":"links/index.html","permalink":"http://just-aleaf.github.io/links/index.html","excerpt":"","text":""},{"title":"有感","date":"2022-08-01T16:30:28.783Z","updated":"2022-08-01T16:30:28.783Z","comments":false,"path":"books/index.html","permalink":"http://just-aleaf.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-08-01T15:10:18.100Z","updated":"2022-08-01T02:39:16.380Z","comments":false,"path":"categories/index.html","permalink":"http://just-aleaf.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-08-01T15:10:16.102Z","updated":"2022-08-01T02:39:16.379Z","comments":false,"path":"about/index.html","permalink":"http://just-aleaf.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2022-08-01T16:29:55.020Z","updated":"2022-08-01T02:39:16.381Z","comments":false,"path":"repository/index.html","permalink":"http://just-aleaf.github.io/repository/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-08-01T16:30:16.870Z","updated":"2022-08-01T02:39:16.377Z","comments":false,"path":"/404.html","permalink":"http://just-aleaf.github.io/404.html","excerpt":"","text":""},{"title":"标签","date":"2022-08-01T16:29:55.883Z","updated":"2022-08-01T02:39:16.382Z","comments":false,"path":"tags/index.html","permalink":"http://just-aleaf.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"出题方法","slug":"出题方法","date":"2022-08-06T08:52:09.000Z","updated":"2022-08-09T15:15:57.187Z","comments":true,"path":"2022/08/06/出题方法/","link":"","permalink":"http://just-aleaf.github.io/2022/08/06/%E5%87%BA%E9%A2%98%E6%96%B9%E6%B3%95/","excerpt":"","text":"我认为一道题最好的理解方式就是去将他制作出来以制作者的心思去理解一道题 MISC(1)lsb隐写什么是lsb隐写:lsb隐写就是通过修改RGB颜色分量的最低有效位(lsb)，而人眼注意不到这前后的变化，通过这个变化来对信息进行隐藏 分析工具：StegSolve通过StegSolve打开对应图片，然后对RGB三原色进行最低位选择，就会显示出隐写内容 除此之外还有zsteg和binwalk强推zsteg 制题思路参考大佬的代码自己修改编写的隐写脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# -*- coding:utf-8 -*-import sysfrom PIL import Imagedef get_key(str): with open(str,&quot;rb&quot;) as f: s=f.read() string=&quot;&quot; for i in range(len(s)):#这里将加密文件通过ord转换为十进制然后在转换为二进制，因为二进制前有’0b‘，利用replace替换，通过zfill函数补位为8位 string=string+&quot;&quot;+(bin(s[i]).replace(&#x27;0b&#x27;,&#x27;&#x27;)).zfill(8) return stringdef mod(x,y): return x%ydef encode(str1,str2,str3): im = Image.open(str1) #获取图片的宽和高 width,height= im.size[0],im.size[1] count = 0 #获取需要隐藏的信息 key = get_key(str2) keylen = len(key) for h in range(height): for w in range(width): pixel = im.getpixel((w,h)) a=pixel[0] b=pixel[1] c=pixel[2] if count == keylen: break #隐藏信息（通过每个像素点的RGB余2，去掉每个像素点的最低为，然后将隐藏的信息取出一位，转换为整形，两者相加 a= a - mod(a, 2)+int(key[count]) count += 1 if count == keylen: im.putpixel((w, h), (a, b, c)) break b = b - mod(b, 2) + int(key[count]) count += 1 if count == keylen: im.putpixel((w, h), (a, b, c)) break c = c - mod(c, 2) + int(key[count]) count += 1 if count == keylen: im.putpixel((w, h), (a, b, c)) break if count % 3 == 0: im.putpixel((w, h), (a, b, c)) im.save(str3) print(&quot;sucess&quot;)if __name__==&#x27;__main__&#x27;: if &#x27;-h&#x27; in sys.argv or &#x27;--help&#x27; in sys.argv or len(sys.argv) &lt; 2: print(&#x27;Usage: python test.py &lt;cmd&gt; [arg...] [opts...]&#x27;) print(&#x27; cmds:&#x27;) print(&#x27; encode image + flag -&gt; image(encoded)&#x27;) print(&#x27; decode length + image(encoded) -&gt; flag&#x27;) sys.exit(1) cmd = sys.argv[1] if cmd != &#x27;encode&#x27; and cmd != &#x27;decode&#x27;: print(&#x27;wrong input&#x27;) sys.exit(1) str1 = sys.argv[2]#获取输入的第二个参数（载体图片的路径） str2 = sys.argv[3]#获取输入的第三个参数（隐写的文件） str3 = sys.argv[4]#获取输入的第四个参数（加密图片的保存路径） if cmd != &#x27;encode&#x27; : print(&#x27;Wrong cmd %s&#x27; % cmd) sys.exit(1) elif cmd==&#x27;encode&#x27;: encode(str1,str2,str3) 发现多了一个图片(测试发现这里只能将加密后文件存储为png文件才会有效) 测试隐写成功 参考浅谈LSB隐写解题与出题 - 知乎 (zhihu.com) (2)伪加密misc中还会经常遇到一种题型就是关于伪加密的 什么是伪加密伪加密就是对文件头的加密标志位进行修改，让用户点开的时候就会显示这是一个加密文件 谈及伪加密就需了解一下zip文件 zip文件由三部分组成： 压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志（文件的各区域开头是50 4B，之后两个字节是版本号，在之后两个字节是判断是否加密的标志位） A.压缩源文件数据区： 50 4B 03 04 头文件标记 xx xx 压缩文件pkware版本 00 00 全局方式位标记（判断有无加密的标志位） （这里判断加密于否的是在头文件标记后间隔2个字节） B.压缩源文件目录区 50 4B 01 02 目录中文件文件头标记 XX XX 压缩使用的pkware版本 XX XX 解压文件所需的pkware版本 00 00 全局方式位标记（判断有无加密的标记位，当改为09，00就可以达到伪加密） C.压缩源文件目录结束标志 50 4B 05 06 目录结束标志 对于识别真假加密的话个人感觉总结的规律有时候也有不准确的时候所以就不进行整理，可以自己修改全局方式标记来进行判断 分析工具：010 Editor这里直接通过010 Editor就可以看到文件对应十六进制寻找到对应文件位置即可 制题思路这里采用ZipCenOp.jar工具 准备一个无密码的zip文件 这里不需要理会报错是java版本问题 解密的使用命令 1java -jar ZipCenOp.jar r 1.zip 参考zip格式压缩包伪加密方法-百度经验 (baidu.com) (3)JPHS隐写什么是JPHS对有压缩JPEG文件进行信息的加密隐藏探测图区工具 分析工具: JPHSJPHIDE:进行将信息隐藏到jpg图片中 JPSEEK:从JPHIDE程序加密隐藏的JPEG图片中探测到并提取到信息文件 Download for Free JPHS for Windows 0.5 (scanwith.com) 制题思路准备一个jpeg图片和隐藏信息 然后打开工具放入jpg照片 放入后点击hide输入解密密码 选择隐藏的信息 将其另存为照片即可 解密同理放入照片点击seek然后输入密码即可 参考(47条消息) 【隐写工具】【试一试？】jphide seek（JPHS） 使用方法,检测提示，附下载地址_黑色地带(崛起)的博客-CSDN博客_jphs使用","categories":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]},{"title":"2022DASCTF Apr X FATE 防疫挑战赛","slug":"2022DASCTF-Apr-X-FATE-防疫挑战赛","date":"2022-08-05T11:55:58.000Z","updated":"2022-08-09T15:05:01.889Z","comments":true,"path":"2022/08/05/2022DASCTF-Apr-X-FATE-防疫挑战赛/","link":"","permalink":"http://just-aleaf.github.io/2022/08/05/2022DASCTF-Apr-X-FATE-%E9%98%B2%E7%96%AB%E6%8C%91%E6%88%98%E8%B5%9B/","excerpt":"","text":"MISCSimpleFlow下载附件发现是一个流量包 尝试binwalk看看有没有什么隐写内容 发现一个flag.txt和一个加密的压缩包 也没有别的有用信息尝试从流量包中查找有没有关于flag或者密码的其他内容 进入wireshark查找flag.txt相关内容 发现有四条发现是base64加密过的蚁剑流量 一一进行解密（这里要注意蚁剑流量解码后s需要去除传入参数的前两个字符） 解密发现压缩包密码 熟悉的猫下载附件发现是一个zip文件名的文件修改后缀位zip 内含一个kdbx和zip文件(加密) kdbx文件是windows的密码文件需要用到keepass进行打开 发现加密 hashcat暴力破解 先使用keepass2john获取hash值 这里生成的txt中要打开将前面的len5:去掉（把那个不属于hash值） 1hashcat -m 13400 keepass.txt -a 0 password.txt --force//这里的password.txt是使用crunch生成的五位数密码本 1hashcat -m 13400 keepass.txt -a 0 password.txt --force --show //显示结果 获得对应密码jbRw5PB2kFmor6IeYYil 解开kbdx文件发现zip文件的密码解密hint中发现k值同时发现存在零宽隐写 Unicode Steganography with Zero-Width Characters (330k.github.io) 通过k和获取到的两个值猜测这里有塔珀自指公式的加密 (41条消息) 代码急转弯——Tupper（塔珀自指公式）_ygys1234的博客-CSDN博客_塔珀自指公式 然后用大佬脚本将k和两个对应值修改 12345678910111213141516171819202122232425import numpy as npimport matplotlib.pyplot as pltfrom PIL import Imagea=22b=160def Tupper_self_referential_formula(k): aa = np.zeros((a,b)) def f(x, y): y += k a1 = 2**-(-a*x - y%a) a2 = (y // a) // a1 return 1 if a2 % 2 &gt; 0.5 else 0 for y in range(a): for x in range(b): aa[y, x] = f(x, y) return aa[:,::-1]k = 92898203278702907929705938676672021500394791427205757369123489204565300324859717082409892641951206664564991991489354661871425872649524078000948199832659815275909285198829276929014694628110159824930931595166203271443269827449505707655085842563682060910813942504507936625555735585913273575050118552353192682955310220323463465408645422334101446471078933149287336241772448338428740302833855616421538520769267636119285948674549756604384946996184385407505456168240123319785800909933214695711828013483981731933773017336944656397583872267126767778549745087854794302808950100966582558761224454242018467578959766617176016660101690140279961968740323327369347164623746391335756442566959352876706364265509834319910419399748338894746638758652286771979896573695823608678008814861640308571256880794312652055957150464513950305355055495262375870102898500643010471425931450046440860841589302890250456138060738689526283389256801969190204127358098408264204643882520969704221896973544620102494391269663693407573658064279947688509910028257209987991480259150865283245150325813888942058aa = Tupper_self_referential_formula(k)plt.figure(figsize=(15,10))plt.imshow(aa,origin=&#x27;lower&#x27;)plt.savefig(&quot;tupper.png&quot;)img = Image.open(&#x27;flag.png&#x27;) 这里得到下图（直接得到的图片是翻转的需要旋转180度） 得到33，121，144三个值 更具经验猜测这里用了猫脸变换(arnold变换) 使用网上脚本进行恢复 123456789101112131415161718192021from PIL import Image img = Image.open(&#x27;flag.png&#x27;)if img.mode == &quot;P&quot;: img = img.convert(&quot;RGB&quot;)assert img.size[0] == img.size[1]dim = width, height = img.size st = 33a = 121b = 144for _ in range(st): with Image.new(img.mode, dim) as canvas: for nx in range(img.size[0]): for ny in range(img.size[0]): y = (ny - nx * a) % width x = (nx - y * b) % height canvas.putpixel((y, x), img.getpixel((ny, nx)))canvas.show() 冰墩墩下载附件发现很多txt文件随便点开一个是一串二进制，和下一个文档位置 点击发现每个里面都有一串二进制且最长的为16进制，看大佬wp知道这里需要进行补位 同时发现有start.txt 这里思路是从头到尾获取二进制然后整合转hex编码获取隐藏内容 网上寻找脚本 123456789101112131415161718192021222324252627import refrom binascii import *tmp_filename = &#x27;start.txt&#x27;bin_data = &#x27;&#x27;while True: try: file_path = &#x27;./BinDunDun/&#x27; + tmp_filename with open(file_path) as f: content = f.read() next_file = re.findall(r&#x27;\\w&#123;10&#125;\\.txt&#x27;, content) if next_file != []: tmp_filename = next_file[0] bin_data += content[:content.find(&#x27; &#x27;)].zfill(16) else: print(file_path) break except: breakhex_data = &#x27;&#x27;with open(&#x27;BinDunDun.zip&#x27;, &#x27;wb&#x27;) as f1: for i in range(0, len(bin_data), 8): hex_data += &#x27;&#123;:02x&#125;&#x27;.format(int(bin_data[i:i+8], 2)) f1.write(unhexlify(hex_data)) 获得压缩包解压获得一个pyc文件和一个受损文件 pyc是py文件编译后文件尝试pyc反编译查看有无线索 python反编译 - 在线工具 (tool.lu) 发现没什么线索在根据pyc尝试pyc隐写（使用剑龙） 获得一串字符串 1BingD@nD@n_in_BeiJing_Winter_Olympics 然后习惯性使用010打开无后缀名文件发现JFIF猜测这里是一个JPG文件修改后缀和文件头 发现是一个冰墩墩照片尝试隐写（菜鸟只想到了binwalk发现没有） 看大佬这里有一串之前密码所以想到了JPHS5 解密获得一串base64解密得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]},{"title":"出题人挑战赛","slug":"出题人挑战赛","date":"2022-08-02T12:28:43.000Z","updated":"2022-08-09T15:16:03.083Z","comments":true,"path":"2022/08/02/出题人挑战赛/","link":"","permalink":"http://just-aleaf.github.io/2022/08/02/%E5%87%BA%E9%A2%98%E4%BA%BA%E6%8C%91%E6%88%98%E8%B5%9B/","excerpt":"","text":"MISC(1)不懂PCB的厨师不是好黑客我们这里下载附件解压发现有题目中的PCB文件夹010打开 然后很简单的crtl+f搜索就可以找到flag (2)卡比知识点:卡比文字，维吉尼亚解密 出题人得多喜欢卡比，确实没想到对应游戏里面的语言，哈哈哈哈哈 上网搜索卡比语言（即使知道是什么也是找了好久） 将给定附件对应翻译即可得到 1PTRH&#123;GWDVSWVQBFISZSZ&#125; 然后这里直接提交发现错误，然后无脑尝试base64发现也不对 然后又想到维吉尼亚密码（加密后也全为英文） 维吉尼亚密码在线加密解密 - 千千秀字 (qqxiuzi.cn) 但是这种解密需要密钥 找遍全部也只有kirby尝试一波发现成功 (3)rootme知识点:SUID提权 开启靶机然后使用xshell进行连接 连接之后尝试管理员权限发现并不可行尝试提权 提权之前就要先了解一下SUID提权 SUID提权（LINUX）A.什么是SUID 首先我们要先了解什么是SUID， SUID是LINUX中的一种特殊类型权限（只作用于二进制可执行文件），当用户在运行一个程序的时候，如果这个程序有SUID权限，那么该程序运行进程的属主就不是发起者，而是文件所属的属主（通俗来说就是当我们以普通用户去运行属主为root且设置了SUID权限的进程时我们可以以root权限去运行该进程达到提权） B.设置SUID权限 12chmod u+s 文件名 //设置SUIDchmod u-s 文件名 //去除SUID 可以通过ls -al查看文件的权限 当我们通过chmod设置权限之后我们可以观察到x变为了s，代表设置成功 C. 提权思路 运行root用户所拥有的SUID文件，当其他用户运行该文件的时候就会获取root身份 这里就需要知道可以进行提权的root设置的SUID权限的二进制可执行文件 123456789nmap vimfindbashmorelessnanocpawk D.探测具有SUID权限的二进制可执行文件 运用于不同系统 123find / -perm -u=s -type f 2&gt;/dev/null/find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb&#123;&#125; 这里以第一条为例进行详细解释 123456find / -perm -u=s -type f 2&gt;/dev/null/-u=s:查找root用户拥有的文件-type:设置正在寻找的文件类型f:常规文件2&gt;/dell/null/:默认&gt;/dev/null为1时为标准输出，为2时会将错误输出到垃圾桶中，通俗点就是不会显示错误整句的意思就是从/目录种查找属主为root同时具备SUID权限的二进制文件并回显，如果有错误就将其输出到dev/null（垃圾桶） E.防范措施 减少对二进制可执行文件赋予SUID权限 回归题目 这里我们就需要用到SUID进行提权 首先查找具有SUID权限属主为root的二进制可执行文件 GTFOBins GTFOBins是一个精心策划的Unix二进制文件列表，可以用来绕过错误配置系统中的本地安全。介绍了当你有某些二进制文件可用是，如何过去root权限 通过题中提示可以看到flag位置 1date -f /root/flag.txt (4)神必流量下载附件发现是一个流量包 binwalk查看是否有什么隐藏文件 发现有一个7z文件进行提取 提取后访问发现需要密码尝试发现并不是伪加密那就乖乖去找密码 只有流量包了尝试找到对应流量分析发现有个123456尝试输入 解密成功给了一个地址 https://drive.google.com/file/d/140MxBVh-OGvQUuk8tmOw4Xm8it9utIzo/view (4)噪音(5)delflagWEB(1)Power Cookie知识点：cookie修改 启动靶机访问抓包发现发送之后Set-cookie中有admin&#x3D;0值 尝试修改cookie为admin&#x3D;1得到flag (2)魔法浏览器知识点:UA修改，js解密 启动靶场发现需要使用魔法浏览器进行访问 f12查看源代码发现给了一串关于ua修改的js 尝试运行 得到uaburp抓包修改获取flag (3)getme知识点:apache2.4.50目录穿透 启动靶场发现 测试发现时apache2.4.50,该版本具有目录穿越的漏洞 1/icons/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd 测试发现确实存在漏洞 访问日志查看是否有flag的相关信息 1/icons/.%%32%65/logs/access_log 找到flag相关信息一个一个进行访问发现前面的都显示400当最后一个的时候回显flag (4)hackme知识点:go语言 开启靶场 第一眼看到也没什么想法随便点点看 process: log: whoami: whereami users: 发现类似于每一个页面里面是一种命令执行 users显示没有找到users.go这个文件，又发现有一个.go文件的上传点，所以猜测这里是上传一个.go的文件然后点击后会对应寻找.go文件进行命令执行 这里上网寻找一个cat&#x2F;flag的go语言脚本（go语言完全没有接触过），然后以flag.go上传 1234567891011121314151617package main import ( &quot;fmt&quot; &quot;os/exec&quot;) func main() &#123; Command(&quot;cat /flag&quot;)&#125; func Command(cmd string) error &#123; c := exec.Command(&quot;bash&quot;, &quot;-c&quot;, cmd) output, err := c.CombinedOutput() fmt.Println(string(output)) return err&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]},{"title":"Dest0g3 520迎新赛","slug":"Dest0g3 520迎新赛","date":"2022-07-31T17:06:01.000Z","updated":"2022-08-09T15:20:24.393Z","comments":true,"path":"2022/08/01/Dest0g3 520迎新赛/","link":"","permalink":"http://just-aleaf.github.io/2022/08/01/Dest0g3%20520%E8%BF%8E%E6%96%B0%E8%B5%9B/","excerpt":"","text":"AI(1)OCR下载发现是一个凌乱的图片尝试使用010 Editor（这里为什么使用该编译器，因为改编译器会提示CRC错误) 这里发现CRC报错说明宽或高方面有问题上网找一个脚本进行宽高的修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import zlib import struct import binascii file = &#x27;flag_pic (2).png&#x27;//只需要将这里的file名改为对应文件名即可 fr = open(file,&#x27;rb&#x27;).read() data = bytearray(fr[12:29]) crc32key = struct.unpack(&#x27;&gt;I&#x27;,fr[29:33])[0]&amp;0xffffffff print(crc32key) n = 4096 for w in range(n): width = bytearray(struct.pack(&#x27;&gt;i&#x27;, w)) for h in range(n): height = bytearray(struct.pack(&#x27;&gt;i&#x27;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] #print(data) crc32result = zlib.crc32(data) if crc32result == crc32key: print(crc32key) print(width,height) print(data) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+&#x27;.png&#x27;,&#x27;wb&#x27;) fw.write(newpic) fw.close 运行得到正常文件这里获得的是一个图片这里就呼应了题目用到了OCRhttps://uutool.cn/ocr/ 12345678910111213141516171819377 ABCAF271C000451FCF397500200000000000062000000000000001D9C97C8E004D002485D002294A676D2FDE351A055C168F9710364AE2D581126E378F3B4C47E15E2E80B74234B849430A221F40C086E06B24ADAAC47F32CB62CADD154B50723E65E50CDF99CC2B953916AD2204D70C15FB493BD4C2E1F93902FB3563190ACEE58CC01621BB2AAAB6EED8CE892FEF5F0927E2C4BCD7C188277D09D0357995A2FB65D31CD99C853D7BAF52EAD8555920D1672B4A3B713917E98FB324AD225A3FA2AFAC1435FFE31ED0COCEFOCAOB68COCCCA81C458680D7C75139429D282984933F7ACFDFB127321D9F4EFCOFEAAE92F985D3C457E90AFBC4DA9D11B23E507A0953036A2EC1D75D69CD1F6A9F0790B1AB02D6C2AFFDF66A2E7E56A1070FBCD316813E12DF9E26FC4813D419792A65960D4D97EDFA7A978A0385C04CF36EFDE3B07DF9B9405253EAA838149910F2571FAA4A8E085D1567C5C17C9B3400F91FBFE6B47E052BA07097C9D77803D3A45E3477FE324603179C7CA6A128CDC0F7E834812618AD4C79934226637E9300C5595E355139A2ECF661A5F63750A6A0035ACF52417AF3A1C1FEA14471D074C27F81C719D98717F4ECD32918BD15C18AB93769E94DDEFD3B6FAF4DDD6628BA44BDEF574FCCD5589334EA8063D7B27A2F0600FC864D010A7F0CEC9B9395434878D01943887194342F9D34FC8F12DD4556ED5A5A36667F9319A0395DB9A445B94C44771B406F962B1CFC8535BA0D3EE3 DDDEB876C95092AAB192B168A732F3A7B9E8156C403C583983F5527A0D6C5D6928481D56955474046D9FC17A2DE21F3D6FC4C69644E7C6A141BE948A417A33D62C6FF6DFAC702A0FC101748D9A9C64A6A0000010406000109825000070B010001212101000C84D100080A0196EAFE6000000501190A0000000000000000000011190044006500730074003000670033002E00740078007400000019020000140A0100B547E05F6654D8011506010020000000000000 发现对应的十六进制我们将其放入编辑器发现是zip文件解压即可得到一个txt文件发现中间base64加密密文解密即可获得flag (2)The correct flag下载附件发现有好多看不到的数据尝试复制粘贴到记事本发现出现数据然后就是词汇分析表示摆烂没搞懂 MISC(1)Pngenius下载附件是一张照片一张照片还是misc不管三七二十一先zsteg看看有没有隐写内容发现一个zip密码说明内藏了一个zip文件所以就在使用binwalk分离一波反手分离出来写入zip密码解压即可获得flag (2)EasyEncode下载附件是个zip文件解压有密码先来试试伪加密防止搞半天白搞发现不是伪加密 那就用ziperello暴力破解一下得出密码位100861得到一段摩斯密码解密得到十六进制数据将内容放到编辑器查看获得unicode编码数据进行转中文发现又url编码再次解码获得base64编码再次解码获得flag (3)你知道js吗下载附件习惯性查看一下16进制发现xml尝试修改后缀为doc打开获得一串数据发现是base64编码的格式解码获得数据发现url编码特点解码发现了brainfuck的特点再次解码获得十六进制数据放入即可获得flag (4)StrangeTraffic没看懂获取tcp后的步骤之后搞懂再补充 (5)EasyWord下载附件返现doc和rar多进行了加密只有hint没有加密查看发现这提示掩码攻击然后就不懂了 (6)Python_jail下载附件发现有三个文件，一个内容为介绍，一个为空，一个是一个加密的zip 更具介绍和空白想到空白编码上工具https://vii5ard.github.io/whitespace/将空白的编码输入进去进行解密解密获得照片 看到照片首先想到lsb 获得得到base64编码base64解码得到flag (7)codegame下载附件名字叫zip那就尝试修改后缀为zip进行解压发现两个文件查看文档发现是LOLCODE编码尝试运行https://www.dcode.fr/lolcode-language网站运行 输入密码解压然后发现还有一个doc文件进去发现是空白摆烂想到题目里面zip改后缀为zip再试试解压发现fllllll1ag文件打开发现是表情果断解密https://aghorler.github.io/emoji-aes/把解压密码带入key尝试解密发现解密不出来 有解不出来摆烂摆烂摆烂然后看到advanced尝试修改发现4时解密成功解密出来16进制数据进行编译器查看 被污染的二维码下载附件发现时一个zip文件名的文件尝试修改后缀位zip发现得到两个文件都拉进010看看十六进制在这里插入图片描述 发现一个是png文件一个是7z文件尝试将png文件进行binwalk分离获再看flag2的十六进制的数据发现文件头有问题正常zip的文件头为377ABCAF更改另存为zip即可获取)使用刚才的密码即可解压获取到一串数据 发现足有127列猜测是零宽http://330k.github.io/misc_tools/unicode_steganography.html网站开解这里解释后要选择前三个（没有理解为什么要选前三个理解之后再回来写）发下隐藏的是N-ZA-M对应想到rot13那就再去rot13一波http://www.mxcz.net/tools/rot13.aspx一看芜湖base64来了解密解密解密崩了啊怎么还隐藏四位只能跑回flag1的照片里面再试试修改后缀为png然后发现磨碎的二维码然后尝试修复https://merricx.github.io/qrazybox/表示对该工具不熟悉我尝试拖进去一直拖不进去没法下一步修补之后扫描即可获得中间四位得到完整二维码 WEBphpdest方法一进入靶机查看发现有require_once要绕过该函数（只要包含过一次便不会包含）然后读取flag4的内容常见的方法就想到了伪协议和多级符号链接的方法结合绕过这里就要了解&#x2F;proc&#x2F;self和&#x2F;proc&#x2F;self&#x2F;root的含义&#x2F;proc&#x2F;self&#x2F;指当前进程，而&#x2F;proc&#x2F;self&#x2F;root&#x2F;指’’&#x2F;‘’这里如果我们知识使用一些proc&#x2F;self&#x2F;root的话最后也会被转化变为正确的路径导致无法绕过，但凡事都有一个上限当我们超过他所能接受的上限就可以导致其无法识别进而无法转换达到绕过的效果 1?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php 进行base64转换即可获取到flag EasyPHP下载靶机发现没什么思路那就代码分析一下 12345678910111213141516171819&lt;?phphighlight_file(__FILE__); //提高亮度没什么用include &quot;fl4g.php&quot;;$dest0g3 = $_POST[&#x27;ctf&#x27;];//post传入擦书$time = date(&quot;H&quot;);//设置时间参数$timme = date(&quot;d&quot;);$timmme = date(&quot;i&quot;);if(($time &gt; &quot;24&quot;) or ($timme &gt; &quot;31&quot;) or ($timmme &gt; &quot;60&quot;))&#123;//条件判断时间超过24小时或者超过31天或者超过60s都是无法实现的 echo $fl4g;&#125;else&#123; echo &quot;Try harder!&quot;;&#125;set_error_handler(//该函数用我的理解就是自己设置报错方式 function() use(&amp;$fl4g) &#123; print $fl4g; &#125;);$fl4g .= $dest0g3;?&gt; Try harder! 由于上面if语句根本不可能实现所以我们就要尝试利用函数set_error_hander进行报错输出 1ctf[]=123 SimpleRCE一进去就看到一堆过滤词汇直接奔溃然后看代码发现str_replace函数一般该函数都是用hex2bin()进行绕过同时发现’()‘和单引号没有过滤那就肯定了这一做法hex2bin的用法大家可以自行百度然后绕过机制就为post传入aaa&#x3D;hex2bin(‘73797374656d’)(hex2bin(‘636174202f666c6167’));&#x2F;&#x2F;system(cat &#x2F;flag)","categories":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-31T17:02:01.949Z","updated":"2022-07-31T17:02:01.949Z","comments":true,"path":"2022/08/01/hello-world/","link":"","permalink":"http://just-aleaf.github.io/2022/08/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://just-aleaf.github.io/tags/CTF/"}]}